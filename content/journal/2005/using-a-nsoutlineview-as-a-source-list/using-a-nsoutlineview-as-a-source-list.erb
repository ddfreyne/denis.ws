<div class="note"><p><strong>Warning:</strong> Even though this article was written three years ago, I considered it to be relevant enough to move it to my new blog. The article itself has been changed slightly, mostly to fix broken URLs. Also, it's probably good to know that <a href="http://chanson.livejournal.com/176310.html">Mac OS 10.5 has native source lists</a> built-in!</p></div>

<p>Ever wondered how to turn a <code>NSOutlineView</code> into a source list? I&#8217;ve been struggling with it for some time, until <a href="http://inessential.com/">Brent Simmons</a> (creator of <a href="http://www.newsgator.com/Individuals/NetNewsWire/Default.aspx">NetNewsWire</a>) pushed me in the right direction. There&#8217;s a lot of information on how to do this floating around on the web, but it&#8217;s carefully hidden or obscured.</p>

<p>The reason why I&#8217;m writing this blog post is to clear things up. Keywords for this blog posts are: <code>NSOutlineView</code>, gradient, source list. The techniques explained here probably also work for <code>NSTableView</code>; your mileage may vary.</p>

<p>Start by creating a <code>NSOutlineView</code> subclass. You&#8217;ll need to add two gradient images to your project: a blue one (active) and a grey one (inactive); I used the ones provided by <a href="http://mattgemmell.com/">Matt Gemmell</a>&#8217;s iTableView (it&#8217;s on the <a href="http://mattgemmell.com/source">Source Code</a> page).</p>

<p>The method that needs to be overridden in order to draw a gradient is <code>-(void)highlightSelectionInClipRect:(NSRect)clipRect</code>.</p>

<p>The first thing I do in this method is checking whether a row is selected. This <em>may</em> be superfluous, but I still consider it good practice. Here&#8217;s the code:</p>

<pre><code><span class="storage">int</span> <span class="variable">selectedRow</span> = [<span class="variable">self</span> <span class="function">selectedRow</span>];
<span class="keyword">if</span>(<span class="variable">selectedRow</span> == <span class="number">-1</span>)
    <span class="keyword">return</span>;
</code></pre>

<p>Secondly, I lock the focus. Always do this when drawing in a view.</p>

<pre><code>[<span class="variable">self</span> <span class="function">lockFocus</span>];
</code></pre>

<p>Next up is the gradient. Depending on whether the view is active or not, a different gradient should be used. A view is &#8220;active&#8221; when its window is the main window, the key window, and the windows&#8217; first responder is the outline view.</p>

<pre><code><span class="storage">NSImage</span> *<span class="variable">gradient</span>;
<span class="keyword">if</span>(([[<span class="variable">self</span> <span class="function">window</span>] <span class="function">firstResponder</span>] == <span class="variable">self</span>) &amp;&amp;
    [[<span class="variable">self</span> <span class="function">window</span>] <span class="function">isMainWindow</span>] &amp;&amp;
    [[<span class="variable">self</span> <span class="function">window</span>] <span class="function">isKeyWindow</span>])
{
    <span class="variable">gradient</span> = [<span class="storage">NSImage</span> <span class="function">imageNamed</span>:<span class="string">@"highlight_blue.tiff"</span>];
}
<span class="keyword">else</span>
{
    <span class="variable">gradient</span> = [<span class="storage">NSImage</span> <span class="function">imageNamed</span>:<span class="string">@"highlight_grey.tiff"</span>];
}
</code></pre>

<p>The gradient is one pixel wide (at least the one I use). We&#8217;ll want the gradient to be scaled horizontally if we want the entire row to have the gradient background, and not just the first pixel. This is how we do it:</p>

<pre><code>[<span class="variable">gradient</span> <span class="function">setScalesWhenResized</span>:<span class="constant">YES</span>];
</code></pre>

<p>We&#8217;ll need to flip the gradient upside down so its get drawn properly.</p>

<pre><code>[<span class="variable">gradient</span> <span class="function">setFlipped</span>:<span class="constant">YES</span>];
</code></pre>

<p>Next, get the rectangle corresponding to the selected row. This is where the gradient needs to be drawn in.</p>

<pre><code><span class="storage">NSRect</span> <span class="variable">drawingRect</span> = [<span class="variable">self</span> <span class="function">rectOfRow</span>:<span class="variable">selectedRow</span>];
</code></pre>

<p>We need the size of the gradient, and the rectangle from which the image shall be drawn.</p>

<pre><code><span class="storage">NSRect</span> <span class="variable">imageRect</span>;
<span class="variable">imageRect</span>.<span class="variable">origin</span> = <span class="constant">NSZeroPoint</span>;
<span class="variable">imageRect</span>.<span class="variable">size</span> = [<span class="variable">gradient</span> <span class="function">size</span>];
</code></pre>

<p>Finally, we draw the gradient. It is drawn in the rectangle corresponding to the selected row (see up). The image is scaled automatically. Also note that we don&#8217;t draw if the rectangle the gradient is drawn into has zero height or zero width.</p>

<pre><code><span class="keyword">if</span>(<span class="variable">drawingRect</span>.<span class="variable">size</span>.<span class="variable">width</span> != <span class="number">0</span> &amp;&amp; <span class="variable">drawingRect</span>.<span class="variable">size</span>.<span class="variable">height</span> != <span class="number">0</span>)
{
    [<span class="variable">gradient</span> <span class="function">drawInRect</span>:<span class="variable">drawingRect</span>
                <span class="function">fromRect</span>:<span class="variable">imageRect</span>
               <span class="function">operation</span>:<span class="constant">NSCompositeSourceOver</span>
                <span class="function">fraction</span>:<span class="number">1.</span>];
}
</code></pre>

<p>We locked the focus before, don&#8217;t forget to unlock it. </p>

<pre><code>[<span class="variable">self</span> <span class="function">unlockFocus</span>];
</code></pre>

<p>This won&#8217;t work yet. You&#8217;ll need to override <code>-(id)_highlightColorForCell:(NSCell *)cell</code> to return <code>nil</code> so the view doesn&#8217;t attempt to draw a solid background color on top of our gradient.</p>

<p>There&#8217;s one more thing. A selected row&#8217;s text color stays black while it should be white. To fix this, we need a <code>NSTextFieldCell</code> subclass which overrides <code>-(void)drawInteriorWithFrame:(NSRect)cellFrame inView:(NSView *)controlView</code> and draws the text in white.</p>

<p>This method starts by checking whether it is highlighted (selected) or not. If it is not, it simply lets the drawing be done by <code>super</code>.</p>

<pre><code><span class="keyword">if</span>(![<span class="variable">self</span> <span class="function">isHighlighted</span>])
{
    [<span class="variable">super</span> <span class="function">drawInteriorWithFrame</span>:<span class="variable">frame</span> <span class="function">inView</span>:<span class="variable">view</span>];
    <span class="keyword">return</span>;
}
</code></pre>

<p>Next, we draw the text in white. I must admit that I mercilessly stole this code from Matt Gemmel's iTableView.</p>

<pre><code><span class="storage">NSRect</span> <span class="variable">inset</span> = <span class="variable">frame</span>;
<span class="variable">inset</span>.<span class="variable">origin</span>.<span class="variable">x</span> += <span class="number">2</span>;
<span class="storage">NSMutableDictionary</span> *<span class="variable">attributes</span> =
    [<span class="storage">NSMutableDictionary</span> <span class="function">dictionaryWithDictionary</span>:
        [[<span class="variable">self</span> <span class="function">attributedStringValue</span>] <span class="function">attributesAtIndex</span>:<span class="number">0</span>
                                         <span class="function">effectiveRange</span>:<span class="constant">NULL</span>
        ]
    ];
[<span class="variable">attributes</span> <span class="function">setValue</span>:[<span class="storage">NSColor</span> <span class="function">whiteColor</span>] <span class="function">forKey</span>:<span class="string">@"NSColor"</span>];
[[<span class="variable">self</span> <span class="function">stringValue</span>] <span class="function">drawInRect</span>:<span class="variable">inset</span> <span class="function">withAttributes</span>:<span class="variable">attributes</span>];
</code></pre>

<p>The last thing we should do is make sure our source list uses this <code>NSTextFieldCell</code> subclass. This belongs in the source list outline view&#8217;s <code>-awakeFromNib</code> method:</p>

<pre><code>[[<span class="variable">self</span> <span class="function">outlineTableColumn</span>]
    <span class="function">setDataCell</span>:[[[<span class="storage">MySourceListTextCell</span> <span class="function">alloc</span>] <span class="function">init</span>] <span class="function">autorelease</span>]
];
</code></pre>

<p>That&#8217;s it. Enjoy!</p>

<p>Before I leave, I&#8217;d like to thank Brent Simmons, Matt Gemmell and, more importantly, all contributors of the <a href="http://www.cocoadev.com/index.pl?NSTableViewInFinderWindows">NSTableViewInFinderWindows</a> article on CocoaDev! Without this article I wouldn&#8217;t have been able to give my outline view that cool gradient.</p>
